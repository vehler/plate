# Plate: Next.js 15 + Payload CMS v3 Boilerplate

A comprehensive Product Requirements Document for building a modern, server-first boilerplate with Next.js 15, Payload CMS v3, and a modular feature architecture designed for rapid application development.

## Executive Summary

**Plate** represents the next generation of full-stack JavaScript boilerplates, leveraging Payload CMS v3's revolutionary Next.js-native architecture. Unlike traditional CMS solutions that require separate backend services, Payload v3 installs directly into your Next.js `/app` folder, enabling true server-first development with **local API access that eliminates HTTP overhead entirely**. This boilerplate emphasizes minimal client-side JavaScript, feature-based modular architecture, and enterprise-grade authentication and user management systems.

The boilerplate targets modern development teams seeking rapid application development without sacrificing performance, security, or scalability. By combining Next.js 15's server components with Payload's local API, applications built with Plate achieve **superior performance metrics** while maintaining developer productivity through automated code generation and standardized patterns.

## Payload CMS Blank Template Foundation

The **Payload CMS blank template** provides a solid foundation that significantly reduces initial setup work. When running `npx create-payload-app` and selecting the "blank" template, you get:

### What's Already Included

**Complete Next.js 15 + Payload CMS v3 Setup**:
- **Pre-configured Next.js 15 project** with app router structure
- **Payload CMS v3 integration** with all required files in `/app/(payload)` folder  which is automatically generated by `npx create-payload-app` with the "blank" template selection and not to be edited
- **MongoDB database adapter** configured and ready to connect
- **Docker setup** with `docker-compose.yml` for development environment
- **Production-ready Dockerfile** with multi-stage builds and standalone output
- **TypeScript configuration** with strict mode enabled
- **Basic package.json** with all essential dependencies and scripts

**Docker Infrastructure**:
- **Development docker-compose.yml** that automatically uses `.env` file
- **MongoDB container** configured and networked with the app
- **Hot reload support** with volume mounting for rapid development
- **Production Dockerfile** optimized for deployment with multi-stage builds

**Authentication System**:
- **Admin user collection** with email/password authentication for super admin access
- **Built-in admin panel** at `/admin` route (super admin only)
- **JWT-based session management** with HTTP-only cookies
- **Role-based access control** foundation for application users

**Project Structure**:
```
src/
├── app/
│   ├── (payload)/           # Payload admin routes (super admin only)
│   │   ├── admin/           # Admin panel (super admin)
│   │   ├── api/            # REST API routes  
│   │   └── [...slug]/      # GraphQL API
│   ├── (public)/           # Public-facing pages (no auth required)
│   │   ├── about/          # About page
│   │   ├── contact/        # Contact page
│   │   └── blog/           # Public blog posts
│   ├── (auth)/             # Authentication pages
│   │   ├── login/          # User login
│   │   ├── register/       # User registration
│   │   ├── forgot-password/ # Password reset
│   │   └── verify/         # Email verification
│   ├── (secure)/           # Protected user pages (auth required)
│   │   ├── account/        # User account management
│   │   │   ├── profile/    # Profile editing
│   │   │   ├── settings/   # Account settings
│   │   │   └── security/   # Password & security
│   │   └── dashboard/      # User dashboard
│   ├── globals.css         # Global styles
│   ├── layout.tsx          # Root layout
│   └── page.tsx           # Landing page
├── collections/            # Empty - ready for your collections
├── payload.config.ts       # Main Payload configuration
└── server.ts              # Server entry point
```

### What Plate Adds to the Foundation

Building on this solid base, **Plate** extends the blank template with:

**Enhanced Feature Architecture**:
- **Feature-based modular system** (`features/core/` and `features/extend/`)
- **Automatic collection registration** via barrel file exports
- **Code generation scripts** for creating new features and collections
- **shadcn/ui integration** with `pnpm dlx shadcn@latest init` setup
- **Component detection** to check existing shadcn components before creating custom ones
- **Separate user authentication system** for application users (distinct from admin panel)

**Extended Core Features**:
- **Dual authentication systems**: Super admin (Payload) and application users (custom frontend)
- **User account management** with `/account` routes for profile, settings, and preferences
- **Enhanced role and permissions** for application users beyond basic admin access
- **Email verification and password reset** flows with email templates for application users
- **Magic link authentication** for passwordless login options in the frontend app

**Development Experience Improvements**:
- **Feature generation CLI** for scaffolding new modules
- **Type-safe feature configuration** with automated registration
- **Enhanced Docker setup** with optimized development workflows
- **Production deployment guides** and configurations

### Server-First Architecture Philosophy

The architecture prioritizes **server-side rendering and computation** to minimize client-side JavaScript bundles while maintaining excellent user experience. This approach leverages Next.js 15's server components to achieve:

- **80-90% server-rendered components** with strategic client-side hydration only where interactivity is required
- **Zero-latency data fetching** through Payload's local API that accesses the database directly without HTTP requests
- **Progressive enhancement** ensuring all functionality works without JavaScript enabled

## Feature-Based Modular Architecture

### Architecture Overview

The boilerplate implements a **dual-module system** distinguishing between core functionality and extensible features:

```
src/
├── app/                        # Next.js App Router
│   ├── (frontend)/            # Public-facing application
│   │   ├── account/           # User account management
│   │   │   ├── profile/       # Profile editing
│   │   │   ├── settings/      # Account settings
│   │   │   └── security/      # Password & security
│   │   ├── auth/              # User authentication
│   │   │   ├── login/         # User login
│   │   │   ├── register/      # User registration
│   │   │   └── reset/         # Password reset
│   │   └── dashboard/         # User dashboard
│   └── (payload)/             # Payload admin routes (super admin only)
├── features/
│   ├── core/                  # Essential system features
│   │   ├── auth/              # User authentication system
│   │   ├── users/             # Application user management
│   │   ├── accounts/          # Account management features
│   │   └── admin/             # Super admin features
│   └── extend/                # Custom business features
│       ├── blog/              # Example: Blog functionality
│       └── dashboard/         # Example: User dashboard
├── shared/
│   ├── components/            # Reusable UI components
│   ├── lib/                   # Utility functions
│   └── types/                 # Shared TypeScript types
└── payload.config.ts          # Payload configuration
```

### Feature Module Structure

Each feature module follows a standardized structure enabling **automatic registration and hot-swappable functionality**:

```
features/core/auth/
├── collections/               # Payload collections
│   ├── Users.ts
├── components/               # Feature-specific components
│   ├── LoginForm.tsx
│   └── RegisterForm.tsx
├── actions/                  # Server actions
│   ├── login.ts
│   └── register.ts
├── hooks/                    # React hooks (client-side)
├── lib/                      # Feature utilities
└── index.ts                  # Feature manifest
```

### Automatic Registration System

The boilerplate implements **automatic collection and feature registration** eliminating manual configuration:

```typescript
// Automatic collection discovery and registration
const collections = await autoDiscoverCollections([
  './features/core/*/collections',
  './features/extend/*/collections'
])

export default buildConfig({
  collections: Object.values(collections),
  // Additional Payload configuration
})
```

## Core Features Specification

### Authentication Architecture

**Dual Authentication System** providing clear separation of concerns:

- **Super Admin Authentication**: Uses Payload's built-in admin panel at `/admin` for system administration, content management, and user oversight
- **Application User Authentication**: Custom frontend authentication system with dedicated routes for user registration, login, and account management
- **Session Management**: Separate session handling for admin vs application users with appropriate security boundaries
- **Role-Based Access Control**: Granular permissions system for application users independent of admin roles

### User Management and Account System

**Frontend Account Management** built for application users:

- **User Registration and Login**: Custom authentication flows using Payload's local API without exposing admin interface
- **Account Management Routes**: Dedicated `/account` path structure for user profile management, settings, and security
- **Profile System**: User profile editing with avatar upload, personal information, and preferences management
- **Role-Based Permissions**: Application-specific roles (user, premium, moderator, etc.) distinct from super admin access
- **Self-Service Account Features**: Password reset, email verification, account deletion, and data export

### File and Media Management

**Robust file handling** leveraging Payload's advanced upload capabilities:

- **Multi-format image support** with automatic optimization and multiple size variants
- **Avatar upload system** with image cropping and optimization
- **Cloud storage integration** supporting AWS S3, Google Cloud Storage, and other providers
- **File access control** with role-based download permissions
- **Media library management** with advanced filtering and organization

## Extended Features Architecture

### Extensibility Framework

The boilerplate provides a **plugin architecture** enabling rapid feature development:

- **Feature generation scripts** creating new modules with consistent structure
- **Automatic route registration** for new feature endpoints
- **Type-safe feature configuration** ensuring compile-time validation
- **Hot module replacement** supporting development-time feature loading

### Role-Based Feature Access

**Granular feature access control** integrated with the RBAC system:

- **Feature-level permissions** controlling access to entire feature sets
- **Dynamic navigation** showing only accessible features to each user role
- **API endpoint protection** securing extended feature endpoints
- **UI component visibility** based on user permissions

## Technical Implementation Details

### Server-Side Data Operations

**Local API integration** providing optimal performance:

```typescript
// Direct database access without HTTP overhead
const posts = await payload.find({
  collection: 'posts',
  where: { status: { equals: 'published' } },
  limit: 10,
  sort: '-createdAt'
})
```

### Frontend Account Management Integration

**Server-side account operations** using Payload's local API:

```typescript
// User account management without exposing admin interface
export default async function AccountPage() {
  const { user } = await getUserFromSession(cookies())
  
  if (!user) {
    redirect('/auth/login')
  }
  
  return <AccountManagementInterface user={user} />
}

// Server action for profile updates
'use server'
export async function updateUserProfile(formData: FormData) {
  const session = await getUserFromSession(cookies())
  
  const updatedUser = await payload.update({
    collection: 'users',
    id: session.user.id,
    data: {
      firstName: formData.get('firstName'),
      lastName: formData.get('lastName'),
      preferences: formData.get('preferences')
    }
  })
  
  revalidatePath('/account/profile')
  return { success: true, user: updatedUser }
}
```

### Form Handling and Validation

**Progressive enhancement** with server-side form processing:

```typescript
// Server action with validation
'use server'
export async function createPost(formData: FormData) {
  const validatedFields = postSchema.safeParse({
    title: formData.get('title'),
    content: formData.get('content')
  })
  
  if (!validatedFields.success) {
    return { error: 'Invalid fields' }
  }
  
  const post = await payload.create({
    collection: 'posts',
    data: validatedFields.data
  })
  
  revalidatePath('/dashboard')
  return { success: true, post }
}
```

## Development Workflow and Tooling

### Package Management with pnpm

**Modern dependency management** with workspace support:

- **pnpm workspaces** enabling monorepo architecture with shared packages
- **Dependency deduplication** reducing node_modules size and installation time
- **Lock file consistency** ensuring reproducible builds across environments
- **Turbo integration** for task orchestration and build caching

### Docker Development and Deployment Environment

**Containerized development and production** ensuring consistency and easy deployment:

- **Hot reload support** with optimized volume mounting for rapid development cycles
- **Multi-stage builds** creating minimal production images
- **Database integration** with MongoDB configured for both development and production
- **Environment isolation** preventing conflicts between projects
- **Production-ready Docker compose** with optimized configurations for deployment

### Code Generation and Developer Experience

**Automated boilerplate generation** accelerating feature development:

```bash
# Generate new feature with complete scaffold
pnpm generate feature --name blog --type extend

# Generate new collection with related components
pnpm generate collection --name products --with-blocks
```

## Deployment and Production Considerations

### Production Architecture

**Docker-first deployment** with scalable containerized architecture:

- **Production Docker containers** with optimized multi-stage builds
- **Docker Compose orchestration** for development and production environments
- **Database clustering** supporting MongoDB replica sets for high availability
- **Environment configuration** using Docker secrets and environment variables
- **Container orchestration** ready for Kubernetes or Docker Swarm deployment

### Security Implementation

**Enterprise-grade security** built into every layer:

- **HTTP-only cookies** preventing XSS attacks on authentication tokens
- **CSRF protection** with Next.js built-in security features
- **Input validation** using Zod schemas at both client and server levels
- **Access control enforcement** at database, API, and UI levels

## Implementation Timeline

## Implementation Timeline

### Phase 1: Foundation Enhancement

**Building on the Payload blank template**:

- **Initialize Plate from blank template** using `npx create-payload-app` with blank template selection
- **Enhance Docker setup** with optimized development and production configurations  
- **Implement feature-based architecture** by restructuring existing collections into `features/core/`
- **Add shadcn/ui integration** with theme configuration and base components
- **Set up automatic collection registration** system to replace manual imports

### Phase 2: Core Feature Enhancements

**Building separate authentication systems**:

- **Frontend user authentication** system distinct from Payload admin panel
- **Account management routes** (`/account/*`) for user profile management and settings
- **Enhanced user collection** with application-specific fields and roles
- **Email verification system** for application users with custom email templates
- **Magic link authentication** as an alternative to password-based login for app users
- **Feature generation CLI** tools for scaffolding new modules and collections

### Phase 3: Extended Features and Developer Experience

**Advanced functionality and tooling**:

- **Extended feature examples** (blog, dashboard) showcasing the modular architecture
- **Advanced file upload system** with image optimization and cloud storage adapters
- **Code generation scripts** for automated feature and collection creation
- **Enhanced development workflow** with improved hot reloading and debugging tools

### Phase 4: Production Optimization and Documentation

**MVP finalization and deployment preparation**:

- **Production Docker optimization** with multi-stage builds and security hardening
- **Deployment documentation** for various hosting platforms and container orchestration
- **Security audit and configuration** ensuring production-ready security standards
- **Complete documentation** including setup guides, feature development, and deployment instructions

## Success Metrics and Validation

### Core Functionality Targets

**Essential MVP goals** building on the Payload blank template foundation:

- **Enhanced Feature Generation**: <5 minutes from command to working feature module
- **Streamlined Setup**: <5 minutes from blank template to Plate-enhanced environment  
- **Docker Development**: <30 seconds for full development environment startup
- **Type Safety**: 100% TypeScript coverage with automated collection type generation
- **Enhanced Authentication**: Complete separation of super admin (Payload) and application user systems with dedicated account management
- **Modular Architecture**: Functional feature-based organization with automatic registration

### Developer Experience Metrics

**Productivity measurements** validating the enhanced developer experience:

- **Template to Plate Conversion**: <5 minutes to transform blank template into Plate architecture
- **Feature Scaffold Generation**: Automated creation of complete feature modules with collections, components, and actions
- **Hot Reload Performance**: <200ms for component changes in Docker development environment  
- **Collection Registration**: Automatic discovery and registration of new collections without manual configuration
- **Documentation Coverage**: Complete guides for extending the blank template foundation with Plate enhancements

## Risk Assessment and Mitigation

### Technical Risks

**Potential challenges** with mitigation strategies:

- **Next.js Version Compatibility**: Payload v3 requires Next.js 15+, potentially limiting ecosystem compatibility
- **Docker Performance**: Development environment performance may vary across different host systems
- **Database Migration Complexity**: MongoDB schema changes require careful version management

### Mitigation Strategies

**Proactive risk management** ensuring project success:

- **Version Pinning**: Lock all major dependencies to tested versions with automated security updates
- **Docker Optimization**: Use multi-stage builds and volume mounting optimization for development performance

## Next.js 15 API Changes and Async Requirements

### Important Breaking Changes in Next.js 15

**Async APIs that now require `await`**:
- `cookies()` - Now returns a Promise, must be awaited: `const cookieStore = await cookies()`
- `headers()` - Now returns a Promise, must be awaited: `const headersList = await headers()`
- `searchParams` - Now returns a Promise in page components: `const params = await searchParams`
- `params` - Now returns a Promise in dynamic routes: `const routeParams = await params`

**Components that must be async**:
- Any Server Component using `cookies()`, `headers()`, `searchParams`, or `params`
- Layout components accessing request data
- Page components with dynamic routes or search parameters
- Middleware and API routes accessing request objects

**Example implementations**:
```typescript
// ❌ Next.js 14 (old way)
export default function ProfilePage({ searchParams }) {
  const cookieStore = cookies()
  const token = cookieStore.get('auth-token')
  // ...
}

// ✅ Next.js 15 (new way)
export default async function ProfilePage({ searchParams }) {
  const cookieStore = await cookies()
  const params = await searchParams
  const token = cookieStore.get('auth-token')
  // ...
}
```

**Authentication utility updates**:
```typescript
// Auth utilities must handle async cookies
export async function getCurrentUser() {
  const cookieStore = await cookies()
  const token = cookieStore.get('payload-token')?.value
  // ...
}

export async function requireAuth() {
  const user = await getCurrentUser()
  if (!user) redirect('/auth/login')
  return user
}
```

## Conclusion and Next Steps

**Plate** represents a significant advancement in full-stack JavaScript development, building strategically on Payload CMS v3's revolutionary blank template foundation. Rather than starting from scratch, Plate enhances the robust base provided by `npx create-payload-app` with advanced modular architecture, automated code generation, and enterprise-grade feature management.

The implementation timeline provides a clear path to MVP readiness within 8 weeks, leveraging the solid Docker and authentication infrastructure already present in the blank template. By extending Payload's Next.js-native architecture with sophisticated feature organization and development tooling, Plate accelerates application development while maintaining the performance and security benefits of the underlying Payload foundation.